import { getProviderById, validateApiKey as validateProviderApiKey } from './aiProviders';

export interface EnvVariable {
  key: string;
  label: string;
  description: string;
  required: boolean;
  defaultValue?: string;
  placeholder?: string;
  validationRegex?: RegExp;
  validationMessage?: string;
  helpUrl?: string;
  dependsOn?: string;
}

export const STATIC_ENV_VARIABLES: EnvVariable[] = [
  {
    key: 'AI_PROVIDER',
    label: 'AI Provider',
    description: 'The AI provider to use (openai, anthropic, google)',
    required: true,
    validationRegex: /^(openai|anthropic|google)$/,
    validationMessage: 'Must be one of: openai, anthropic, google'
  },
  {
    key: 'NEXT_PUBLIC_API_URL',
    label: 'Backend API URL',
    description: 'The URL of your backend API server',
    required: true,
    defaultValue: 'http://localhost:3003',
    placeholder: 'http://localhost:3003',
    validationRegex: /^https?:\/\/.+/,
    validationMessage: 'Please enter a valid URL starting with http:// or https://'
  },
  {
    key: 'SUPABASE_URL',
    label: 'Supabase Project URL',
    description: 'Your Supabase project URL (optional, for future database integration)',
    required: false,
    placeholder: 'https://your-project.supabase.co',
    validationRegex: /^https:\/\/.+\.supabase\.co$/,
    validationMessage: 'Please enter a valid Supabase URL'
  },
  {
    key: 'SUPABASE_ANON_KEY',
    label: 'Supabase Anonymous Key',
    description: 'Your Supabase anonymous/public key (optional)',
    required: false,
    placeholder: 'eyJ...',
    validationRegex: /^eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+$/,
    validationMessage: 'Please enter a valid JWT token'
  }
];

export function getProviderSpecificVariables(providerId?: string): EnvVariable[] {
  if (!providerId) return [];
  
  const provider = getProviderById(providerId);
  if (!provider) return [];

  return [
    {
      key: provider.environmentVariables.apiKey,
      label: `${provider.displayName} API Key`,
      description: `API key for ${provider.displayName}`,
      required: true,
      placeholder: provider.apiKeyFormat.example,
      validationRegex: provider.apiKeyFormat.regex,
      validationMessage: `Please enter a valid ${provider.displayName} API key`,
      helpUrl: provider.apiKeyUrl
    },
    {
      key: provider.environmentVariables.model,
      label: `${provider.displayName} Model`,
      description: `The specific model to use from ${provider.displayName}`,
      required: true,
      validationMessage: 'Please select a model'
    }
  ];
}

export function getAllEnvVariables(providerId?: string): EnvVariable[] {
  return [...STATIC_ENV_VARIABLES, ...getProviderSpecificVariables(providerId)];
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

export function validateEnvVariable(variable: EnvVariable, value: string, providerId?: string): ValidationResult {
  const errors: string[] = [];

  if (variable.required && !value.trim()) {
    errors.push(`${variable.label} is required`);
    return { isValid: false, errors };
  }

  if (value.trim() && variable.validationRegex && !variable.validationRegex.test(value)) {
    errors.push(variable.validationMessage || `Invalid format for ${variable.label}`);
  }

  // Special validation for API keys using provider-specific logic
  if (providerId && value.trim() && variable.key.includes('API_KEY')) {
    const isValidApiKey = validateProviderApiKey(providerId, value);
    if (!isValidApiKey) {
      errors.push(variable.validationMessage || `Invalid API key format for ${variable.label}`);
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

export function validateAllEnvVariables(values: Record<string, string>, providerId?: string): ValidationResult {
  const allErrors: string[] = [];
  const variables = getAllEnvVariables(providerId);

  for (const variable of variables) {
    const value = values[variable.key] || '';
    const result = validateEnvVariable(variable, value, providerId);
    allErrors.push(...result.errors);
  }

  return {
    isValid: allErrors.length === 0,
    errors: allErrors
  };
}

export function generateEnvTemplate(values: Record<string, string>, providerId?: string): string {
  const timestamp = new Date().toISOString();
  const lines: string[] = [
    '# AI Interview Prep Platform Environment Configuration',
    '# Generated by Setup Wizard',
    `# Created on ${timestamp}`,
    '# Place this file as .env in your project root directory',
    '',
  ];

  const variables = getAllEnvVariables(providerId);
  const provider = providerId ? getProviderById(providerId) : null;

  if (provider) {
    lines.push(`# ${provider.displayName} Configuration`);
    lines.push(`# Get your API key at: ${provider.apiKeyUrl}`);
    lines.push('');
  }

  // Group variables by category
  const coreVars = variables.filter(v => ['AI_PROVIDER', 'OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'GOOGLE_API_KEY', 'OPENAI_MODEL', 'ANTHROPIC_MODEL', 'GOOGLE_MODEL'].includes(v.key));
  const appVars = variables.filter(v => v.key.startsWith('NEXT_PUBLIC_'));
  const optionalVars = variables.filter(v => v.key.startsWith('SUPABASE_'));

  // Core AI configuration
  if (coreVars.length > 0) {
    lines.push('# AI Provider Configuration');
    for (const variable of coreVars) {
      if (variable.description) {
        lines.push(`# ${variable.description}`);
      }
      const value = values[variable.key] || variable.defaultValue || '';
      lines.push(`${variable.key}=${value}`);
    }
    lines.push('');
  }

  // Application configuration
  if (appVars.length > 0) {
    lines.push('# Application Configuration');
    for (const variable of appVars) {
      if (variable.description) {
        lines.push(`# ${variable.description}`);
      }
      const value = values[variable.key] || variable.defaultValue || '';
      lines.push(`${variable.key}=${value}`);
    }
    lines.push('NODE_ENV=development');
    lines.push('');
  }

  // Optional services
  if (optionalVars.length > 0) {
    lines.push('# Optional Database Configuration');
    lines.push('# Uncomment and configure if using Supabase for data persistence');
    for (const variable of optionalVars) {
      const value = values[variable.key] || '';
      if (value.trim()) {
        lines.push(`${variable.key}=${value}`);
      } else {
        lines.push(`# ${variable.key}=${variable.placeholder || 'your_value_here'}`);
      }
    }
    lines.push('');
  }

  lines.push('# Security Notes:');
  lines.push('# - Never commit this file to version control');
  lines.push('# - Add .env to your .gitignore file');
  lines.push('# - Keep your API keys secure and private');
  lines.push('# - Restart your development server after changing these values');

  return lines.join('\n');
}

export function checkCurrentEnvVariables(providerId?: string): Record<string, boolean> {
  const status: Record<string, boolean> = {};
  const variables = getAllEnvVariables(providerId);
  
  for (const variable of variables) {
    if (typeof window !== 'undefined') {
      status[variable.key] = variable.key.startsWith('NEXT_PUBLIC_') 
        ? !!process.env[variable.key]
        : false;
    } else {
      status[variable.key] = !!process.env[variable.key];
    }
  }
  
  return status;
}

export function downloadEnvFile(content: string, filename: string = '.env'): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function copyToClipboard(text: string): Promise<boolean> {
  if (navigator.clipboard && window.isSecureContext) {
    return navigator.clipboard.writeText(text).then(() => true).catch(() => false);
  } else {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      return Promise.resolve(successful);
    } catch {
      document.body.removeChild(textArea);
      return Promise.resolve(false);
    }
  }
}